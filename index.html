<!doctype html>
<!--
    Revenue Analysis Dashboard

    SETUP INSTRUCTIONS:
    1. Create a GitHub repository for your revenue dashboard
    2. Upload this index.html file to the repo
    3. Upload your revenue_analysis_current.xlsx file to the repo
    4. Enable GitHub Pages in repository settings (Settings > Pages > Source: main branch)
    5. Update the EXCEL_FILE_URL constant in this file (line ~265) with your GitHub raw file URL
       Format: https://raw.githubusercontent.com/YOUR_USERNAME/YOUR_REPO/main/revenue_analysis_current.xlsx
    6. Every time you run your analysis script, commit and push the new Excel file to GitHub
    7. The dashboard will automatically fetch and display the latest data when loaded

    Your dashboard URL will be: https://YOUR_USERNAME.github.io/YOUR_REPO/
-->
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Revenue Analysis Dashboard</title>

    <!-- SheetJS for Excel reading -->
    <script src="https://cdn.sheetjs.com/xlsx-0.18.5/package/dist/xlsx.full.min.js"></script>

    <!-- ApexCharts for beautiful visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>

    <!-- Grid.js for data tables -->
    <link href="https://unpkg.com/gridjs/dist/theme/mermaid.min.css" rel="stylesheet" />
    <script src="https://unpkg.com/gridjs/dist/gridjs.umd.js"></script>

    <!-- Bootstrap for tabs -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3a0ca3;
            --accent: #f72585;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .dashboard-container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .dashboard-header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 30px;
            text-align: center;
        }

        .dashboard-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }


        .nav-tabs {
            background: #f8f9fa;
            padding: 20px 20px 0;
            border-bottom: 2px solid #dee2e6;
        }

        .nav-tabs .nav-link {
            color: #495057;
            font-weight: 600;
            border: none;
            border-radius: 10px 10px 0 0;
            margin-right: 5px;
            padding: 12px 24px;
            transition: all 0.3s ease;
        }

        .nav-tabs .nav-link:hover {
            background: #e9ecef;
        }

        .nav-tabs .nav-link.active {
            background: white;
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
        }

        .tab-content {
            padding: 30px;
        }

        .sheet-content {
            display: grid;
            gap: 30px;
        }

        .charts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #212529;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f1f3f5;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .data-table-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
        }

        .table-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #212529;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table-container {
            max-height: 600px;
            overflow-y: auto;
            border-radius: 8px;
        }

        /* Grid.js customization */
        .gridjs-wrapper {
            border-radius: 8px;
            box-shadow: none !important;
        }

        .gridjs-table {
            border-collapse: collapse;
        }

        .gridjs-th {
            background: linear-gradient(135deg, var(--primary), var(--secondary)) !important;
            color: white !important;
            font-weight: 600 !important;
            padding: 15px !important;
        }

        .gridjs-td {
            padding: 12px 15px !important;
            border-bottom: 1px solid #e9ecef !important;
        }

        .gridjs-tr:hover {
            background-color: #f8f9fa !important;
        }


        .processing {
            text-align: center;
            padding: 60px;
        }

        .processing i {
            font-size: 4rem;
            color: var(--primary);
            animation: spin 1.5s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.95rem;
            opacity: 0.9;
        }

        @media (max-width: 768px) {
            .charts-section {
                grid-template-columns: 1fr;
            }

            .dashboard-header h1 {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="dashboard-header">
            <h1><i class="fas fa-chart-pie"></i> Revenue Analysis Dashboard</h1>
            <p>Interactive visualization of your Excel data with beautiful charts and tables</p>
        </div>

        <div id="processing" class="processing" style="display: block;">
            <i class="fas fa-spinner"></i>
            <h3>Processing Excel file...</h3>
            <p style="color: #6c757d;">Creating visualizations and tables</p>
        </div>

        <div id="dashboardContent" style="display: none;">
            <ul class="nav nav-tabs" id="sheetTabs" role="tablist"></ul>
            <div class="tab-content" id="sheetTabContent"></div>
        </div>
    </div>

    <script>
        let workbookData = {};
        let gridInstances = {};

        // Configuration: Update this URL to your GitHub raw file URL
        const EXCEL_FILE_URL = 'https://raw.githubusercontent.com/YOUR_USERNAME/YOUR_REPO/main/revenue_analysis_current.xlsx';

        async function loadExcelFromURL() {
            try {
                document.getElementById('processing').style.display = 'block';

                const response = await fetch(EXCEL_FILE_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.arrayBuffer();
                await processExcelFile(data);
            } catch (error) {
                console.error('Error loading Excel file:', error);
                document.getElementById('processing').innerHTML = `
                    <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: var(--danger);"></i>
                    <h3 style="color: var(--danger); margin-top: 20px;">Failed to load data</h3>
                    <p style="color: #6c757d;">Error: ${error.message}</p>
                    <p style="color: #6c757d; font-size: 0.9rem; margin-top: 10px;">
                        Please update the EXCEL_FILE_URL in the HTML file with your GitHub repository URL.
                    </p>
                `;
            }
        }

        async function processExcelFile(data) {
            try {
                const workbook = XLSX.read(data, { type: 'array' });

                // Filter out Sheet1 and empty sheets
                const validSheets = workbook.SheetNames.filter(name => {
                    if (name === 'Sheet1') return false;
                    const worksheet = workbook.Sheets[name];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    return jsonData.length > 1; // Has more than just headers
                });

                if (validSheets.length === 0) {
                    document.getElementById('processing').innerHTML = `
                        <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: var(--danger);"></i>
                        <h3 style="color: var(--danger); margin-top: 20px;">No valid sheets found</h3>
                        <p style="color: #6c757d;">The Excel file doesn't contain any valid data sheets.</p>
                    `;
                    return;
                }

                // Process each valid sheet
                validSheets.forEach(sheetName => {
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    workbookData[sheetName] = {
                        headers: jsonData[0] || [],
                        rows: jsonData.slice(1).filter(row => row.some(cell => cell != null))
                    };
                });

                renderDashboard(validSheets);

                document.getElementById('processing').style.display = 'none';
                document.getElementById('dashboardContent').style.display = 'block';

            } catch (error) {
                console.error('Error processing Excel file:', error);
                document.getElementById('processing').innerHTML = `
                    <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: var(--danger);"></i>
                    <h3 style="color: var(--danger); margin-top: 20px;">Error processing Excel file</h3>
                    <p style="color: #6c757d;">Error: ${error.message}</p>
                    <p style="color: #6c757d; font-size: 0.9rem;">Please make sure the Excel file is valid.</p>
                `;
            }
        }

        function renderDashboard(sheetNames) {
            const tabsContainer = document.getElementById('sheetTabs');
            const contentContainer = document.getElementById('sheetTabContent');

            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';

            sheetNames.forEach((sheetName, index) => {
                // Create tab
                const tabId = `tab-${index}`;
                const tabButton = document.createElement('li');
                tabButton.className = 'nav-item';
                tabButton.innerHTML = `
                    <button class="nav-link ${index === 0 ? 'active' : ''}"
                            id="${tabId}-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#${tabId}"
                            type="button">
                        <i class="fas fa-table"></i> ${sheetName}
                    </button>
                `;
                tabsContainer.appendChild(tabButton);

                // Create tab content
                const tabPane = document.createElement('div');
                tabPane.className = `tab-pane fade ${index === 0 ? 'show active' : ''}`;
                tabPane.id = tabId;
                tabPane.innerHTML = `<div class="sheet-content" id="content-${index}"></div>`;
                contentContainer.appendChild(tabPane);

                // Render sheet content
                setTimeout(() => renderSheetContent(sheetName, index), 100);
            });
        }

        function renderSheetContent(sheetName, index) {
            const container = document.getElementById(`content-${index}`);
            const data = workbookData[sheetName];

            // Create charts section
            const chartsHTML = createChartsSection(sheetName, data, index);

            // Create data table section
            const tableHTML = `
                <div class="data-table-section">
                    <div class="table-title">
                        <i class="fas fa-database"></i> Complete Data (${data.rows.length} rows)
                    </div>
                    <div class="table-container" id="table-${index}"></div>
                </div>
            `;

            container.innerHTML = chartsHTML + tableHTML;

            // Render charts
            renderChartsForSheet(sheetName, data, index);

            // Render data table with Grid.js
            renderDataTable(data, index);
        }

        function createChartsSection(sheetName, data, index) {
            const charts = getRelevantCharts(sheetName, data);

            if (charts.length === 0) return '';

            let html = '<div class="charts-section">';
            charts.forEach((chart, chartIndex) => {
                html += `
                    <div class="chart-card">
                        <div class="chart-title">
                            <i class="fas fa-chart-${chart.icon}"></i> ${chart.title}
                        </div>
                        <div id="chart-${index}-${chartIndex}"></div>
                    </div>
                `;
            });
            html += '</div>';
            return html;
        }

        function getRelevantCharts(sheetName, data) {
            const charts = [];
            const nameLower = sheetName.toLowerCase();

            // Monthly Summary
            if (nameLower.includes('monthly summary')) {
                charts.push(
                    { type: 'line', title: 'Monthly Revenue Trend', icon: 'line' },
                    { type: 'bar', title: 'Revenue by Category', icon: 'bar' }
                );
            }
            // Daily Summary
            else if (nameLower.includes('daily summary')) {
                charts.push(
                    { type: 'line', title: 'Daily Revenue Trend', icon: 'line' },
                    { type: 'area', title: 'Daily Services Volume', icon: 'area-chart' }
                );
            }
            // Client Analysis
            else if (nameLower.includes('client analysis')) {
                charts.push(
                    { type: 'bar', title: 'Top 20 Clients by Revenue', icon: 'bar' },
                    { type: 'pie', title: 'Client Tier Distribution', icon: 'pie' }
                );
            }
            // Service Analysis
            else if (nameLower.includes('service analysis')) {
                charts.push(
                    { type: 'bar', title: 'Revenue by Service', icon: 'bar' },
                    { type: 'pie', title: 'Revenue Contribution %', icon: 'pie' }
                );
            }
            // Category Deep Dive
            else if (nameLower.includes('category')) {
                charts.push(
                    { type: 'bar', title: 'Category Performance', icon: 'bar' },
                    { type: 'pie', title: 'Revenue Distribution', icon: 'pie' }
                );
            }
            // Revenue Trends
            else if (nameLower.includes('revenue trends')) {
                charts.push(
                    { type: 'line', title: 'Revenue Trend Over Time', icon: 'line' },
                    { type: 'bar', title: 'Month-over-Month Comparison', icon: 'bar' }
                );
            }
            // Forecast
            else if (nameLower.includes('forecast')) {
                charts.push(
                    { type: 'line', title: 'Revenue Forecast (3 Scenarios)', icon: 'line' },
                    { type: 'stats', title: 'Forecast Key Metrics', icon: 'chart-area' }
                );
            }
            // Default: try to find numeric columns
            else {
                const numericCols = findNumericColumns(data);
                if (numericCols.length > 0) {
                    charts.push({ type: 'bar', title: 'Data Overview', icon: 'bar' });
                }
            }

            return charts;
        }

        function renderChartsForSheet(sheetName, data, index) {
            const charts = getRelevantCharts(sheetName, data);
            const nameLower = sheetName.toLowerCase();

            charts.forEach((chart, chartIndex) => {
                const chartId = `chart-${index}-${chartIndex}`;

                if (nameLower.includes('monthly summary') || nameLower.includes('revenue trends')) {
                    renderMonthlyRevenueChart(data, chartId, chart.type, chart.title);
                } else if (nameLower.includes('daily summary')) {
                    renderDailyChart(data, chartId, chart.type, chart.title);
                } else if (nameLower.includes('client analysis')) {
                    renderClientChart(data, chartId, chart.type, chart.title);
                } else if (nameLower.includes('service analysis')) {
                    renderServiceChart(data, chartId, chart.type, chart.title);
                } else if (nameLower.includes('category')) {
                    renderCategoryChart(data, chartId, chart.type, chart.title);
                } else if (nameLower.includes('forecast')) {
                    if (chart.type === 'stats') {
                        renderForecastStats(data, chartId);
                    } else {
                        renderForecastChart(data, chartId);
                    }
                } else {
                    renderGenericChart(data, chartId, chart.type);
                }
            });
        }

        function renderMonthlyRevenueChart(data, chartId, type, title) {
            const monthCol = findColumnIndex(data.headers, ['month', 'yearmonth', 'year-month']);
            const revenueCol = findColumnIndex(data.headers, ['revenue', 'monthly revenue']);

            if (monthCol === -1 || revenueCol === -1) return;

            const categories = data.rows.map(row => row[monthCol]).filter(v => v);
            const values = data.rows.map(row => parseFloat(row[revenueCol]) || 0);

            const options = {
                series: [{
                    name: 'Revenue (RON)',
                    data: values
                }],
                chart: {
                    type: type,
                    height: 350,
                    toolbar: { show: true }
                },
                xaxis: {
                    categories: categories,
                    labels: { rotate: -45 }
                },
                yaxis: {
                    labels: {
                        formatter: (val) => val.toLocaleString() + ' RON'
                    }
                },
                stroke: { curve: 'smooth', width: 3 },
                colors: ['#4361ee'],
                dataLabels: { enabled: false },
                title: { text: title, align: 'left' }
            };

            new ApexCharts(document.querySelector(`#${chartId}`), options).render();
        }

        function renderDailyChart(data, chartId, type, title) {
            const dateCol = findColumnIndex(data.headers, ['date']);
            const revenueCol = findColumnIndex(data.headers, ['revenue', 'total revenue']);
            const servicesCol = findColumnIndex(data.headers, ['services', 'total services']);

            const col = title.includes('Revenue') ? revenueCol : servicesCol;
            if (dateCol === -1 || col === -1) return;

            // Take last 30 days
            const last30 = data.rows.slice(-30);
            const categories = last30.map(row => {
                const dateVal = row[dateCol];
                // Handle Excel serial dates
                if (typeof dateVal === 'number' && dateVal > 40000 && dateVal < 50000) {
                    const d = excelSerialToDate(dateVal);
                    return d.toLocaleDateString('en-GB', { month: 'short', day: 'numeric' });
                }
                return formatDate(dateVal);
            });
            const values = last30.map(row => parseFloat(row[col]) || 0);

            const options = {
                series: [{
                    name: title.includes('Revenue') ? 'Revenue (RON)' : 'Services',
                    data: values
                }],
                chart: {
                    type: type === 'area' ? 'area' : 'line',
                    height: 350,
                    toolbar: { show: true }
                },
                xaxis: {
                    categories: categories,
                    labels: { rotate: -45 }
                },
                stroke: { curve: 'smooth', width: 2 },
                colors: ['#f72585'],
                fill: { type: 'gradient' },
                title: { text: title + ' (Last 30 Days)', align: 'left' }
            };

            new ApexCharts(document.querySelector(`#${chartId}`), options).render();
        }

        function renderClientChart(data, chartId, type, title) {
            if (type === 'pie') {
                const tierCol = findColumnIndex(data.headers, ['tier', 'client tier']);
                if (tierCol === -1) return;

                const tiers = {};
                data.rows.forEach(row => {
                    const tier = row[tierCol];
                    tiers[tier] = (tiers[tier] || 0) + 1;
                });

                const options = {
                    series: Object.values(tiers),
                    labels: Object.keys(tiers),
                    chart: { type: 'pie', height: 350 },
                    colors: ['#4361ee', '#f72585', '#10b981', '#f59e0b'],
                    legend: { position: 'bottom' },
                    title: { text: title, align: 'left' }
                };

                new ApexCharts(document.querySelector(`#${chartId}`), options).render();
            } else {
                const clientCol = findColumnIndex(data.headers, ['client']);
                const spentCol = findColumnIndex(data.headers, ['spent', 'total spent']);

                if (clientCol === -1 || spentCol === -1) return;

                const top20 = data.rows.slice(0, 20);
                const clients = top20.map(row => row[clientCol]);
                const spent = top20.map(row => parseFloat(row[spentCol]) || 0);

                const options = {
                    series: [{ name: 'Total Spent (RON)', data: spent }],
                    chart: { type: 'bar', height: 350, toolbar: { show: true } },
                    xaxis: { categories: clients, labels: { rotate: -45 } },
                    yaxis: { labels: { formatter: (val) => val.toLocaleString() + ' RON' } },
                    colors: ['#4361ee'],
                    plotOptions: { bar: { horizontal: false } },
                    title: { text: title, align: 'left' }
                };

                new ApexCharts(document.querySelector(`#${chartId}`), options).render();
            }
        }

        function renderServiceChart(data, chartId, type, title) {
            const serviceCol = findColumnIndex(data.headers, ['service']);
            const revenueCol = findColumnIndex(data.headers, ['revenue', 'total revenue']);

            if (serviceCol === -1 || revenueCol === -1) return;

            const services = data.rows.map(row => row[serviceCol]);
            const revenues = data.rows.map(row => parseFloat(row[revenueCol]) || 0);

            if (type === 'pie') {
                const options = {
                    series: revenues,
                    labels: services,
                    chart: { type: 'donut', height: 350 },
                    colors: ['#4361ee', '#f72585', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'],
                    legend: { position: 'bottom' },
                    title: { text: title, align: 'left' }
                };
                new ApexCharts(document.querySelector(`#${chartId}`), options).render();
            } else {
                const options = {
                    series: [{ name: 'Revenue (RON)', data: revenues }],
                    chart: { type: 'bar', height: 350 },
                    xaxis: { categories: services, labels: { rotate: -45 } },
                    yaxis: { labels: { formatter: (val) => val.toLocaleString() + ' RON' } },
                    colors: ['#10b981'],
                    title: { text: title, align: 'left' }
                };
                new ApexCharts(document.querySelector(`#${chartId}`), options).render();
            }
        }

        function renderCategoryChart(data, chartId, type, title) {
            const categoryCol = findColumnIndex(data.headers, ['category', 'mega category']);
            const revenueCol = findColumnIndex(data.headers, ['revenue', 'total revenue', '% of revenue']);

            if (categoryCol === -1 || revenueCol === -1) return;

            const categories = data.rows.map(row => row[categoryCol]).filter(v => v && v !== 'TOTAL');
            const revenues = data.rows.map(row => parseFloat(row[revenueCol]) || 0).filter(v => v > 0);

            if (type === 'pie') {
                const options = {
                    series: revenues,
                    labels: categories,
                    chart: { type: 'pie', height: 350 },
                    colors: ['#4361ee', '#f72585', '#10b981', '#f59e0b', '#ef4444'],
                    legend: { position: 'bottom' },
                    title: { text: title, align: 'left' }
                };
                new ApexCharts(document.querySelector(`#${chartId}`), options).render();
            } else {
                const options = {
                    series: [{ name: 'Revenue', data: revenues }],
                    chart: { type: 'bar', height: 350 },
                    xaxis: { categories: categories },
                    colors: ['#f72585'],
                    title: { text: title, align: 'left' }
                };
                new ApexCharts(document.querySelector(`#${chartId}`), options).render();
            }
        }

        function renderForecastChart(data, chartId) {
            // Revenue Forecast sheet has multi-row headers - need to find the actual header row
            let actualHeaders = data.headers;
            let actualRows = data.rows;

            // Check if current headers don't contain "Forecast Month" - means we need to find them in rows
            const hasValidHeaders = data.headers.some(h =>
                h && h.toString().toLowerCase().includes('forecast month')
            );

            if (!hasValidHeaders) {
                // Search through first few rows to find the actual headers
                for (let i = 0; i < Math.min(5, data.rows.length); i++) {
                    const row = data.rows[i];
                    const hasForecastMonth = row.some(cell =>
                        cell && cell.toString().toLowerCase().includes('forecast month')
                    );
                    if (hasForecastMonth) {
                        actualHeaders = row;
                        actualRows = data.rows.slice(i + 1);
                        console.log('Found actual headers in row', i, actualHeaders);
                        break;
                    }
                }
            }

            const monthCol = findColumnIndex(actualHeaders, ['month', 'forecast month']);
            const conservativeCol = findColumnIndex(actualHeaders, ['conservative']);
            const moderateCol = findColumnIndex(actualHeaders, ['moderate']);
            const optimisticCol = findColumnIndex(actualHeaders, ['optimistic']);

            console.log('Column indices:', { monthCol, conservativeCol, moderateCol, optimisticCol });
            console.log('Headers:', actualHeaders);

            if (monthCol === -1 || conservativeCol === -1) {
                console.log('Forecast columns not found', actualHeaders);
                return;
            }

            // Filter to only rows that have actual forecast data (exclude stat rows)
            const forecastRows = actualRows.filter(row => {
                const monthValue = row[monthCol];
                // Check if month looks like a date or month string, not a stat label
                return monthValue &&
                       monthValue.toString().match(/\d{4}-\d{2}/) &&  // Must match YYYY-MM format
                       !monthValue.toString().includes('Average') &&
                       !monthValue.toString().includes('Baseline') &&
                       !monthValue.toString().includes('Growth') &&
                       !monthValue.toString().includes('Median');
            });

            console.log('Forecast rows found:', forecastRows.length);

            if (forecastRows.length === 0) {
                console.log('No forecast rows found');
                return;
            }

            // Format month labels properly (could be "2026-01" or Excel date)
            const months = forecastRows.map(row => {
                const monthVal = row[monthCol];
                if (typeof monthVal === 'string' && monthVal.match(/\d{4}-\d{2}/)) {
                    // Format "2026-01" to "Jan 2026"
                    const [year, month] = monthVal.split('-');
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    return monthNames[parseInt(month) - 1] + ' ' + year;
                }
                return monthVal.toString();
            });

            const conservative = forecastRows.map(row => parseFloat(row[conservativeCol]) || 0);
            const moderate = forecastRows.map(row => parseFloat(row[moderateCol]) || 0);
            const optimistic = forecastRows.map(row => parseFloat(row[optimisticCol]) || 0);

            console.log('Forecast data:', { months, conservative, moderate, optimistic });

            // Calculate averages for each scenario
            const avgConservative = conservative.reduce((a,b) => a+b, 0) / conservative.length;
            const avgModerate = moderate.reduce((a,b) => a+b, 0) / moderate.length;
            const avgOptimistic = optimistic.reduce((a,b) => a+b, 0) / optimistic.length;

            const options = {
                series: [
                    { name: 'Conservative', data: conservative },
                    { name: 'Moderate', data: moderate },
                    { name: 'Optimistic', data: optimistic }
                ],
                chart: {
                    type: 'line',
                    height: 400,
                    toolbar: { show: false },
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800
                    }
                },
                xaxis: {
                    categories: months,
                    labels: {
                        style: { fontSize: '13px', fontWeight: 600 }
                    }
                },
                yaxis: {
                    labels: {
                        formatter: (val) => val.toLocaleString('ro-RO', {maximumFractionDigits: 0}) + ' RON',
                        style: { fontSize: '12px' }
                    }
                },
                stroke: { curve: 'smooth', width: 3 },
                colors: ['#ef4444', '#3b82f6', '#10b981'],
                markers: {
                    size: 5,
                    strokeWidth: 2,
                    hover: { size: 7 }
                },
                legend: {
                    position: 'top',
                    fontSize: '14px',
                    fontWeight: 600,
                    markers: { width: 14, height: 14, radius: 4 },
                    horizontalAlign: 'center'
                },
                grid: {
                    borderColor: '#e5e7eb',
                    strokeDashArray: 4
                },
                dataLabels: {
                    enabled: false
                },
                tooltip: {
                    shared: true,
                    intersect: false,
                    y: {
                        formatter: (val) => val.toLocaleString('ro-RO', {maximumFractionDigits: 0}) + ' RON'
                    }
                }
            };

            new ApexCharts(document.querySelector(`#${chartId}`), options).render();
        }

        function renderForecastStats(data, chartId) {
            // Find the stats from the data table
            const statsRows = data.rows.filter(row => {
                const firstCell = row[0] ? row[0].toString() : '';
                return firstCell.includes('Average') ||
                       firstCell.includes('Baseline') ||
                       firstCell.includes('Growth') ||
                       firstCell.includes('Median');
            });

            if (statsRows.length === 0) {
                document.querySelector(`#${chartId}`).innerHTML = '<p style="padding: 20px; text-align: center; color: #6c757d;">No forecast statistics available</p>';
                return;
            }

            // Extract key stats
            const stats = {};
            statsRows.forEach(row => {
                const key = row[0] ? row[0].toString() : '';
                const value = row[1];
                stats[key] = value;
            });

            console.log('Forecast stats:', stats);

            // Create a beautiful stats display
            let statsHTML = `
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; padding: 10px;">
            `;

            Object.entries(stats).forEach(([key, value]) => {
                const isPercentage = key.includes('%') || key.includes('Growth');

                // Handle percentage values - they're already in decimal form (0.0283 for 2.83%)
                let formattedValue;
                if (isPercentage) {
                    // Value is already decimal (e.g., 0.0283), convert to percentage
                    if (typeof value === 'number') {
                        formattedValue = (value * 100).toFixed(2) + '%';
                    } else if (typeof value === 'string') {
                        // If it's already formatted as string percentage
                        formattedValue = value;
                    } else {
                        formattedValue = value;
                    }
                } else {
                    // RON values
                    formattedValue = typeof value === 'number'
                        ? value.toLocaleString('ro-RO', {maximumFractionDigits: 0}) + ' RON'
                        : value;
                }

                const numericValue = typeof value === 'number' ? value : parseFloat(value);
                const color = isPercentage && numericValue > 0 ? '#10b981' :
                             isPercentage && numericValue < 0 ? '#ef4444' : '#4361ee';

                statsHTML += `
                    <div style="background: linear-gradient(135deg, ${color}15, ${color}05);
                                border-left: 4px solid ${color};
                                padding: 15px;
                                border-radius: 8px;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                        <div style="font-size: 0.85rem; color: #6c757d; margin-bottom: 5px; font-weight: 500;">
                            ${key}
                        </div>
                        <div style="font-size: 1.5rem; font-weight: 700; color: ${color};">
                            ${formattedValue}
                        </div>
                    </div>
                `;
            });

            statsHTML += '</div>';

            document.querySelector(`#${chartId}`).innerHTML = statsHTML;
        }

        function renderGenericChart(data, chartId, type) {
            const numericCols = findNumericColumns(data);
            if (numericCols.length === 0) return;

            const col = numericCols[0];
            const values = data.rows.map(row => parseFloat(row[col]) || 0).slice(0, 20);
            const labels = data.rows.map((row, i) => row[0] || `Row ${i+1}`).slice(0, 20);

            const options = {
                series: [{ name: data.headers[col], data: values }],
                chart: { type: type, height: 350 },
                xaxis: { categories: labels, labels: { rotate: -45 } },
                colors: ['#4361ee'],
                title: { text: data.headers[col] || 'Data', align: 'left' }
            };

            new ApexCharts(document.querySelector(`#${chartId}`), options).render();
        }

        function renderDataTable(data, index) {
            const tableId = `table-${index}`;

            // Format data for Grid.js
            const columns = data.headers.map(h => ({ name: h || 'Column', width: 'auto' }));
            const rows = data.rows.map(row =>
                data.headers.map((_, i) => formatCellValue(row[i]))
            );

            new gridjs.Grid({
                columns: columns,
                data: rows,
                search: true,
                sort: true,
                pagination: {
                    enabled: true,
                    limit: 50,
                    summary: true
                },
                style: {
                    table: { 'font-size': '14px' }
                },
                className: {
                    table: 'table-striped'
                }
            }).render(document.getElementById(tableId));
        }

        // Helper functions
        function findColumnIndex(headers, keywords) {
            for (let keyword of keywords) {
                const index = headers.findIndex(h =>
                    h && h.toString().toLowerCase().includes(keyword.toLowerCase())
                );
                if (index !== -1) return index;
            }
            return -1;
        }

        function findNumericColumns(data) {
            const numeric = [];
            for (let i = 0; i < data.headers.length; i++) {
                const sample = data.rows.slice(0, 5).map(row => row[i]);
                if (sample.some(v => v !== null && !isNaN(parseFloat(v)))) {
                    numeric.push(i);
                }
            }
            return numeric;
        }

        function excelSerialToDate(serial) {
            // Excel serial date starts from 1900-01-01
            // Excel incorrectly treats 1900 as a leap year, so we need to account for that
            if (serial < 1) return null;

            const utc_days = Math.floor(serial - 25569);
            const utc_value = utc_days * 86400;
            const date_info = new Date(utc_value * 1000);

            return date_info;
        }

        function formatDate(date) {
            if (!date) return '';

            // Check if it's an Excel serial date (number between 1 and 100000)
            if (typeof date === 'number' && date > 1 && date < 100000) {
                const d = excelSerialToDate(date);
                if (d && !isNaN(d)) {
                    return d.toLocaleDateString('en-GB', { year: 'numeric', month: 'short', day: 'numeric' });
                }
            }

            // Try to parse as regular date
            const d = new Date(date);
            if (isNaN(d)) return date;
            return d.toLocaleDateString('en-GB', { year: 'numeric', month: 'short', day: 'numeric' });
        }

        function formatCellValue(value) {
            if (value === null || value === undefined) return '';

            // Check if it's an Excel serial date (number between 40000-50000 range for recent dates)
            if (typeof value === 'number' && value > 40000 && value < 50000) {
                return formatDate(value);
            }

            if (typeof value === 'number') {
                return value.toLocaleString('ro-RO', { maximumFractionDigits: 2 });
            }
            return value.toString();
        }

        // Auto-load Excel file from GitHub on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadExcelFromURL();
        });
    </script>
</body>
</html>
